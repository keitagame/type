<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Canvas</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden; /* スクロールバーを消す */
    }
    canvas {
      image-rendering: crisp-edges;
      image-rendering: pixelated;
      display: block; /* 余計な隙間を消す */
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
const textures = [
  'star1.png', // 小さめ
  'star2.png', // 中くらい
  'star2.png'  // 大きめ
].map(src => {
  const img = new Image();
  img.src = src;
  return img;
});
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d",{ alpha: false });
    ctx.imageSmoothingEnabled = false;
    const img = new Image();
    const star = new Image();
    const stt = new Image();
    stt.src="starship2.png"
    const starship = new Image();
    starship.src="starship.png";
    const back = new Image();
    let words = ["apple", "banana", "cherry", "grape", "orange"];
    let currentWord = words[Math.floor(Math.random() * words.length)];
    let ox = 0;
    let oy = 0;
    let input = "";
    let score = 0;
    back.src="e.jpg";
    star.src="star1.png";
   const flakes = [];
const FLAKE_COUNT = 10;        // 雪の量
const GRAVITY = 0.05;           // 落下加速度
const WIND_BASE = 0.4;          // 風の平均
const WIND_VARIATION = 0.6;     // 風の揺れ幅
const DRIFT_FREQ = 0.0018;      // 横ゆらぎの周波数
const ROT_SPEED = 0.01;         // 回転の速さ上限
function rand(min, max) { return Math.random() * (max - min) + min; }
let stts = [];
function spawnFlake(y = rand(-canvas.height, 0)) {
  const tex = textures[Math.floor(Math.random() * textures.length)];
  const scale = rand(0.4, 1.2); // サイズばらつき
  const baseSpeed = rand(0.6, 1.6);
  return {
    x: rand(0, canvas.width),
    y,
    vx: 0,
    vy: baseSpeed,
    angle: rand(0, Math.PI * 2),
    vr: rand(-ROT_SPEED, ROT_SPEED),
    tex,
    w:20,
    h:20,
    driftPhase: rand(0, 1000)
  };
}
function addstt(){
    stta = {x:canvas.width,y:rand(0, canvas.height)};
    stts.push(stta);
}
let gameover = false;
function upstt(){
    for(var i = 0; i < stts.length; i++){
        if(stts[i].x < 200){
            gameover=true;
        }
        stts[i].x-=12;

        }
}
function init() {
  for (let i =0; i<flakes.length; i++){
    
    flakes.push(spawnFlake(rand(0, canvas.height))); // 画面内に初期配置
  }
  
}

    img.src = "board.png"; // 任意の画像URL
    // ベンダープレフィックス（古いブラウザ用）
    ctx.mozImageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.msImageSmoothingEnabled = false;
    // Theme colors
const COL_BG = '#0a0f14';
const COL_GRID = '#15f1ff';
const COL_GLOW = 'rgba(21, 241, 255, 0.08)';
const COL_SCAN = 'rgba(255,255,255,0.05)';
const COL_STARS = '#9af7ff';
let t = 0;
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const cssWidth  = window.innerWidth;
    const cssHeight = window.innerHeight;
    ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
    // デバイスのピクセル比 (Retinaなら2など)
    const dpr = window.devicePixelRatio || 1;

    // 実際のキャンバス解像度を拡大
    canvas.width  = cssWidth * dpr;
    canvas.height = cssHeight * dpr;

    // CSSサイズはそのまま
    canvas.style.width  = cssWidth + "px";
    canvas.style.height = cssHeight + "px";

    // 座標系をスケーリング
    //ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function drowm(){
ctx.font = "bold 62px 'Courier New'";

ctx.textAlign = "center";
ctx.textBaseline = "middle";
  // 入力済み部分
  ctx.fillStyle = "lime";
  ctx.fillText(input, ox, oy+165);
ctx.font = "bold 132px 'Courier New'";
  // 未入力部分
  ctx.fillStyle = "white";
  ctx.fillText(currentWord, ox, oy+15);
ctx.fillStyle = "rgba(0,255,255,0.1)";

  
    }
    function drawo(){
        
        ox=canvas.width/2;
        oy=canvas.height/2-100;
        // サイズを指定して描画 (200x200に縮小)
        ctx.drawImage(img, canvas.width/2-500, canvas.height/2-290, 1000, 500);
    }
function drawfw(){
 const w = canvas.width, h = canvas.height;

  // Subtle vignette
  const g = ctx.createRadialGradient(w*0.5, h*0.6, h*0.05, w*0.5, h*0.6, h*0.8);
  g.addColorStop(0, 'rgba(0,0,0,0)');
  g.addColorStop(1, 'rgba(0,0,0,0.6)');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, w, h);

  
}
let tamas = [];
let tick = 0;
// 星画像（差し替え推奨）。同一オリジンかCORS許可が必要。
  const starImg = new Image();
  // 例: starImg.src = '/assets/star.png';
  starImg.src = ''; // 空ならフォールバック描画を使う
  let imgReady = false;
  starImg.onload = () => { imgReady = true; };
  starImg.onerror = () => { imgReady = false; };

  // 星のパラメータ
  const STAR_MIN_SIZE = 8;
  const STAR_MAX_SIZE = 10;
  const SPEED_MIN = 40;   // px/s
  const SPEED_MAX = 240;  // px/s
  const SPAWN_PER_SEC = 4; // 1秒あたり生成数
  const MAX_STARS = 50;

  const stars = [];
  let last = performance.now();
  let spawnCarry = 0;

  function randRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  function spawnStar() {
    const size = randRange(STAR_MIN_SIZE, STAR_MAX_SIZE);
    const y = randRange(0, canvas.height);
    const speed = randRange(SPEED_MIN, SPEED_MAX);
    const twinkle = Math.random() < 0.3; // きらめき有無
    const alphaPhase = Math.random() * Math.PI * 2;

    stars.push({
      x: canvas.width, // 右端の少し外から
      y,
      w: size,
      h: size,
      v: speed,
      twinkle,
      phase: alphaPhase
    });
  }

  function drawStarShape(x, y, r) {
    // 5角スター形状（フォールバック）
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    const spikes = 5, outer = r, inner = r * 0.5;
    let rot = Math.PI / 2 * 3;
    let cx = 0, cy = 0;
    const step = Math.PI / spikes;
    ctx.moveTo(0, -outer);
    for (let i = 0; i < spikes; i++) {
      cx = Math.cos(rot) * outer; cy = Math.sin(rot) * outer; ctx.lineTo(cx, cy);
      rot += step;
      cx = Math.cos(rot) * inner; cy = Math.sin(rot) * inner; ctx.lineTo(cx, cy);
      rot += step;
    }
    ctx.closePath();
    // グローっぽい縁取り
    ctx.shadowColor = '#ffffaa';
    ctx.shadowBlur = r * 0.8;
    ctx.fillStyle = '#fff8d6';
    ctx.fill();
    ctx.restore();
  }
function drawb(){
ctx.drawImage(back, 0,0, canvas.width, canvas.height);
}

let xi = 200;
  function drawst(){


for (let i = 0; i < stts.length; i++) {
  
    if(stts[i].y <xi) {
    xi-=10;
}
if(stts[i].y >xi) {
    xi+=10;
}
  
}
console.log(xi);
ctx.drawImage(starship, 200,xi, 200, 200);
}
function addtamas(){
tamas.push({x:200,y:xi});
}
function uptamas(){
for(var i = 0; i<tamas.length; i++){
tamas[i].x+=30;
}
}
function drawstt(){
for(var i = 0; i < stts.length; i++){
        ctx.drawImage(stt, stts[i].x,stts[i].y, 200, 200);
        }
}
  function update(dt) {
    // 生成
    spawnCarry += SPAWN_PER_SEC * dt;
    while (spawnCarry >= 1 && stars.length < MAX_STARS) {
      spawnStar();
      spawnCarry -= 1;
    }
    // 移動
    for (let s of stars) {
      s.x -= s.v * dt;
      s.phase += dt * 2; // きらめき速度
    }
    // 画面外を削除
    for (let i = stars.length - 1; i >= 0; i--) {
      if (stars[i].x + stars[i].w < -32) stars.splice(i, 1);
    }
  }

  function render(dt) {
    
    for (let s of stars) {
      // きらめきアルファ
      const baseAlpha = 1.0;
      const twinkleAmp = s.twinkle ? 0.35 : 0.0;
      const a = baseAlpha - twinkleAmp * (0.5 + 0.5 * Math.sin(s.phase));

      ctx.globalAlpha = Math.max(0.1, Math.min(1, a));

      if (imgReady && starImg.src) {
        ctx.drawImage(starImg, s.x - s.w / 2, s.y - s.h / 2, s.w, s.h);
      } else {
        drawStarShape(s.x, s.y, s.w / 2);
      }
    }
    ctx.globalAlpha = 1;
  }
function draws() {
  tick++;
  // 背景クリア
  

  const wind = WIND_BASE + Math.sin(tick * 0.002) * WIND_VARIATION; // 緩やかな風

  for (const f of flakes) {
    // 物理更新
    f.vy += GRAVITY * 0.02; // 僅かな加速
    const drift = Math.sin(f.driftPhase + tick * DRIFT_FREQ) * 0.6; // 横ゆらぎ
    f.vx = wind + drift;

    f.x += f.vx;
    f.y += f.vy;
    f.angle += f.vr;

    // 画面外処理（下に出たら上から再利用、横はラップ）
    if (f.y - f.h > canvas.height) {
        
      const nf = spawnFlake(-rand(10, 200));
      nf.x = f.x % canvas.width;
      Object.assign(f, nf);
    }
    if (f.x < -f.w) f.x = canvas.width + f.w;
    if (f.x > canvas.width + f.w) f.x = -f.w;

    // 描画（回転あり）
    if (f.tex.complete) {
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.angle);
      ctx.globalAlpha = 0.85; // ほんの少し透明に
      ctx.drawImage(f.tex, -f.w / 2, -f.h / 2, f.w, f.h);
      ctx.restore();
    }
  }

  
}
function drawtama(){
    ctx.fillStyle = "white";
    for(var i =0; i<tamas.length; i++){
      ctx.fillRect(tamas[i].x+200, tamas[i].y+100, 20, 6);
}
}
    function drawf() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      t += 0.016;

  // Clear
  

 
      
    }
    function main(now) {
if(gameover){return;}
        ctx.clearRect(0,0,canvas.width,canvas.height);
      drawf();
drawb();
 const dt = Math.min(0.05, (now - last) / 200); // 安定化
    last = now;
    update(dt);
    render(dt);
  
draws();
        drawo();
drawtama();
uptamas();
drawst();
drawstt();
upstt();
	    //ここに繰り返したいものを書く
        drowm();
      //drawfw();
       
        if (input === currentWord) {
      score++;
            stts.shift();
      currentWord = words[Math.floor(Math.random() * words.length)];
input = "";
    }
	    requestAnimationFrame(main);
    }
    requestAnimationFrame(main);
let inta = 3000;
const intervalId = setInterval(() => {
  addstt();
  inta-=10;
}, inta);
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas(); // 初期化
     document.addEventListener("keydown", (e) => {
addtamas();
  if (e.key === "Backspace") {
    input = input.slice(0, -1);
  } else if (e.key === "Enter") {
    
    input = "";
  } else if (/^[a-z]$/i.test(e.key)) {
    
  }
  const expectedChar = currentWord[input.length];

  // 一致したら追加、ミスなら何もしない（非表示・非反映）
  if (e.key.toLowerCase() === expectedChar?.toLowerCase()) {
    input += expectedChar; // 大文字/小文字扱いを統一
  } else {
    // ミス演出（短いフラッシュ）
    missFlashUntil = performance.now() + 120;
    // ここで効果音やバイブレーションなども可能
    // navigator.vibrate?.(30);
  }

  
});
Promise.all(textures.map(t => new Promise(res => t.onload = res))).then(init);
  </script>
</body>
</html>
